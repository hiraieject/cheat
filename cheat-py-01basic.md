
# Python cheat-sheet 01-basic

## 変数とデータ型

Pythonでは変数には型がなく、変数にはどの型のオブジェクトでも代入できる

変数が参照するオブジェクトにデータ型がある。(型と値のペアを保持するイメージ)

|データ型|説明|例 |
|:-----------|:-----------|:----------|
|int        | 整数          |0、128、1_234_567（アンダースコアによる桁区切り）、0b1010（2進表記）、-0o11（8進表記）、0x1111（16進表記） |
|float      | 浮動小数点    |1.0、-1_000.000_123（アンダースコアによる桁区切り）、1.2e+2（指数表記） |
|complex	| 「実数部＋虚数部」からなる複素数。虚数部の末尾には「j」を付加| 1+1j、(2.5-2.5j) |
|str        | 文字列。変更不可能 | 'string'、"double quote"、'''triple quote'''、"""triple quote"""、r"abc\n"（raw文字列。「\n」はエスケープシーケンスではなく、「\」と「n」が連続したものと見なされる）、f"value: {x}"（f文字列。「{}」で囲まれた部分に変数屋敷の値が埋め込まれる）|
|bytes      | バイナリデータ。変更不可能 | b'hello world'、b"goodbye world"、b'''triple quoted bin data'''、b"""triple quoted bin data"""|
|bytearray	| 変更可能なバイナリデータ | bytearray(b'hello world')（bytes型の値をbytearray関数に渡して変更可能なバージョンを取得）|
|bool       | 真偽値。TrueかFalseのみをその値とする	| True、False |
|list       | リスト。複数要素を格納する | [0, 1, 2]、[[0, 1], [2, 3]]（リストを要素とするリスト）、[x for x in range(10)]（リスト内包表記。0～9を要素とするリストを生成）|
|tuple      | タプル。複数要素を格納する。変更不可能 | (0, 1, 2)、((0, 1), (2, 3))（タプルを要素とするタプル）、([0, 1], [2, 3])（リストを要素とするタプル。格納されたリストの要素は変更可能）、()（要素を持たないタプル）、(1,)（要素を1つだけ持つタプル）|
|dict       | キー／値の組を格納する | {'name': 'deep insider'}、{'zero': 0, 'one': 1}、{key: value for key, value in zip(['zero', 'one'], [0, 1])}（辞書内包表記）|
|set        | 集合。1つの集合の中で要素の重複はなく、要素に順序もない | {0, 1, 2}、{x for x in range(10)}（集合内包表記）|
|frozenset	| 変更不可能な集合 | frozenset([0, 1, 2])（リスト[0, 1, 2]をfrozenset関数に与えて、リストと同じ要素を持つ変更不可能な集合を得る） |
|range      | 整数の範囲。スタート値、ストップ値、ステップ値を持つ。実際の範囲にはストップ値は含まれない（ストップ値より小さな整数の範囲となる）| range(5)（0～4の範囲）、range(0, 10, 2)（0～9の範囲だが、ステップ値が2なので偶数のみから成る）|

各データ型にはその名前と同じ名前の関数が用意されている

その関数を使い、その型のオブジェクトを作成できる

    # 関数を使用した各データ型のオブジェクトの定義例
    print(int('100'))                   # 文字列'100'から整数値100を作成
    print(float(1))                     # 整数値1から浮動小数点数値1.0を作成
    print(str(100))                     # 整数値100から文字列'100'を作成
    print(list('hello'))                # 文字列'hello'の各文字を要素とするリストを作成
    print(tuple([0, 1, 2]))             # 引数に指定したリストと同じ要素を持つタプルを作成
    print(tuple())                      # 要素を持たないタプルを作成
    print(tuple([1]))                   # 要素を1つだけ持つタプルを作成
    print(dict(foo='foo', bar='bar'))   # dict関数にキーワード引数を渡して辞書を作成

変数は事前に定義や宣言をせずに必要なところで使用できる。ただし、変数の値を読み出す前には初期化（代入）が必要。

    # 変数の使用例
    x = 1                       # 変数は宣言なしに使用可能
    x += 1                      # 変数xの値に1を加算
    mylist = [range(0, 10, 2)]  # 変数mylistにリスト[0, 2, 4, 6, 8]を代入
    mylist = tuple(mylist)      # 変数には型がないので、任意の型のオブジェクトを代入可能
    print(not_defined)          # 初期化をしていない変数not_definedの値を表示（例外が発生）

　既に述べたように、変数には型がないので、任意の型のオブジェクトを代入できる。上記コード例の4行目では「mylist」という名前の変数にタプルを代入しているが、これはエラーとはならない（が、コードの可読性を下げるので推奨はされない）。最後の行では、初期化をしていない変数の値を利用しようとしているので、次のように例外が発生する。

実行結果
実行結果
制御構造
　Pythonにはプログラムの実行の流れ（フロー）を制御する構文として以下がある。

構文	要素
if文	条件分岐
for文	繰り返し処理
while文	繰り返し処理
break文	繰り返し処理の中断
continue文	次の繰り返し処理の開始
Pythonの制御構造
　以下ではこれらについてまとめる。なお、これらの制御構文に限らず、Pythonの複合文（複数の文で構成される文）は、一般に各節の先頭行はコロン「:」で終了し、その後は空白文字によるインデントを付けて、その節に含まれるブロック（コードブロック）を明記する。

if文
　if文は何らかの条件に応じて、実行したい処理を分岐させるために使用する。その構文を以下に示す。

if 条件0:
    条件0が真だったときに実行するブロック
elif 条件1:
    条件0が偽で、条件1が真だったときに実行するブロック
elif 条件2:
    条件0と条件1が偽で、条件2が真だったときに実行するブロック
else:
    全ての条件が偽だったときに実行するブロック

if文の構文
　elif節は任意の数だけ繰り返すことが可能。また、elif節とelse節は省略可能である。


AWS初心者、データ保存～分析に挑戦　「S3」活用　BIツール連携も　結果は？
　条件には比較演算子を使った値比較を記述する。ただし、Pythonでは、全てのオブジェクトが真または偽として評価できるので、直接オブジェクト（を参照する変数）を条件として記述することも可能だ。偽となるのは以下のものだ。

None（オブジェクトがないことを示す値）とFalse
整数の0、浮動小数点数の0.0など、ゼロを表す数値型の値
空文字列、空のリスト、空のタプルなど、要素を持たない反復可能オブジェクト
　これらのオブジェクトを条件に指定すると、それは成り立たないことになる。他のオブジェクトは全て真の値として取り扱われる。

　以下に例を示す。

condition1 = 1
if condition1 == 1:  # elif節とelse節のないif文
    print('condition is True')

name = ""  # 空文字列を変数nameに代入
if name:  # 空文字列は偽として扱われる
    print(f'name: {name}')
else:  # elif節を省略
    print('no name')

condition2 = 100
if condition1 != 0 and condition2 == 0:  # 比較演算子と論理演算子による条件記述
    print('some result')
elif condition1 == 10:
    print('another result')
else:
    print('final result')

if文の使用例
　なお、Pythonには他の言語に見られるswitch文がないので、条件による処理の分岐にはif文を常に使用する。

for文
　Pythonのfor文は、リストなどの反復可能オブジェクトの要素を1つずつ取り出して、それを使用して何らかの処理を行う際に使用することが多い。あるいは、range関数を使用することで特定回数の繰り返し処理を行うことも可能だ。その構文を以下に示す。

for ループ変数 in 反復可能オブジェクト:
    反復可能オブジェクトから取り出した値（ループ変数の値）を使った処理
else:
    反復可能オブジェクトの要素がなくなったときに行う処理

for文の構文
　if文と同様に、else節は省略可能だ。else節は反復可能オブジェクトの要素がなくなり、繰り返し処理が終了したときに実行される（反復可能オブジェクトが空の場合には繰り返し処理を行わずにelse節のコードが実行される）。ただし、for文で行う繰り返し処理の中でbreak文が実行された場合には、else節は実行されない（後述）。

　以下に例を示す。

mylist = list(range(5))
for num in mylist:
    if num % 2 == 0:  # 偶数なら
        print(f'{num}は偶数です')
    else:  # 奇数なら
        print(f'{num}は奇数です')

mystr = ''  # 空文字列
for ch in mystr:  # mystrは空文字列なのでelse節のみが実行される
    print(ch, end='')
else:
    print()
    print('finished')

for文の使用例
while文
　while文は、それに指定した条件が真である限り、処理を繰り返すのに使用する。構文を以下に示す。

while 条件:
    条件が真の間、繰り返す処理
else:
    条件が偽になったときに行う処理

while文
　if文やfor文と同様に、else節は省略可能だ。else節は条件が偽となり、繰り返し処理が終了する際に実行される。ただし、while文で行う繰り返し処理の中でbreak文が実行された場合にはelse節は実行されない（後述）。

　以下に例を示す。

counter = 0
while counter < 5:
    print(counter)  # 変数counterの値が5より小さい間実行する処理
    counter += 1
else:
    print('finished')  # 繰り返し処理が終わったときに実行する処理

while文の使用例
break文とcontinue文
　break文は繰り返し処理の中で、一定の条件が成立したら繰り返しを終了させるのに使用する。以下に例を示す。

for num in range(5):  # ループ変数numの値は0～4に変化する
    if num == 3:  # ループ変数numの値が3ならループを終了
        break
    print(num)  # このprint関数呼び出しはelse節に書いても書かなくても同じこと
else:
    print('finished')

break文の使用例
　この例では、ループ変数numの値が3のときにbreak文が実行される。その時点で繰り返し処理が終了するので、ループ変数の値が4になることはない。また、print関数を呼び出す前にbreak文が実行されるので、この値が出力されることもないし、else節が実行されることもない。実行結果を以下に示す。

実行結果
実行結果
　一方、continue文は繰り返し処理の中で、一定の条件が成立したら、次の繰り返しを開始するのに使用する。以下に例を示す。

for num in range(5):
    if num % 2 == 0:  # 変数numの値が偶数なら次の繰り返しを開始
        continue
    print(num)
else:
    print('finished')

continue文の使用例
　この例では、ループ変数numの値が偶数のときにcontinue文が実行される。これにより繰り返し処理の新しい繰り返しが開始されるので、print関数呼び出しが実行されない。そのため、画面には奇数のみが表示される。また、最後にはelse節も実行される。

演算子
　Pythonでは多くの演算子が提供されている。その幾つかを以下に抜粋してまとめる。

算術演算子
　算術演算子を以下にまとめる。

演算子	説明	例
**	べき乗（累乗）	2 ** 10→1024
単項+	被演算子の符号をそのままとする	+2→2
単項-	被演算子の符号を反転する	-(-2)→2
*	乗算、文字列の繰り返し	2 * 5→10、'foo' * 2→'foofoo'
/	除算	1 / 2→0.5
//	整数除算の商	7 // 3→2
%	整数除算の剰余	7 % 3→1
+	加算、文字列の結合	1 + 9→10、'foo' + 'bar'→'foobar'
-	減算	10 - 1→9
Pythonの四則演算子
代入演算子／累算代入演算子
　代入演算子と累算代入演算子を以下にまとめる。例では変数xの値を10とし、累算代入演算子では「→」の後に変数xに代入された値を示す。

演算子	説明	例
=	代入	x = 10
+=	左辺の値に右辺の値を加算した値を左辺に代入	x += 10→20（x = x + 10に相当）
-=	左辺の値から右辺の値を減算した値を左辺に代入	x -= 10→0（x = x - 10に相当）
*=	左辺の値と右辺の値を乗算した値を左辺に代入	x *= 2→20（x = x * 2に相当）
/=	左辺の値を右辺の値で除算した値を左辺に代入	x /= 2→5.0（x = x / 2に相当）
//=	左辺の値を右辺の値で整数除算した商を左辺に代入	x //= 3→3（x = x // 3に相当）
%=	左辺の値を右辺の値で整数除算した剰余を左辺に代入	x %= 3→1（x = x % 3に相当）
**=	左辺の値を右辺の値で累乗した値を左辺に代入	x **= 2→100（x = x ** 2に相当）
>>=	左辺の値を右辺の値だけ右ビットシフトした値を左辺に代入	x >>= 1→5（x = x >> 1に相当）
<<=	左辺の値を右辺の値だけ左ビットシフトした値を左辺に代入	x <<= 1→20（x = x << 1に相当）
&=	左辺の値と右辺の値のビット単位論理積を左辺に代入	x &= 8→8（x = x & 8に相当）
|=	左辺の値と右辺の値のビット単位論理和を左辺に代入	x |= 7→15（x = x | 7に相当）
^=	左辺の値と右辺の値のビット単位排他的論理和を左辺に代入	x ^= 12→6（x = x ^ 12に相当）
代入演算子／累算代入演算子
比較演算子とブール演算子
　比較演算子とブール演算子はif文やwhile文の条件を記述するときなどに使用する。

演算子	説明	例
==	2つのオブジェクトの値が等しいかどうか	1 == 0→False
[2, 3] == [2, 3]→True
!=	2つのオブジェクトの値が等しくないかどうか	1 != 0→True
'foo' != 'foo'→False
>	左側のオブジェクトの値が右側のオブジェクトの値よりも大きいかどうか	0 > 1→False
[1, 2, 3] > [1, 2]→True
>=	左側のオブジェクトの値が右側のオブジェクトの値以上かどうか	0 >= 0→True
[1, 2] >= [1, 2, 3]→False
<	左側のオブジェクトの値が右側のオブジェクトの値よりも小さいかどうか	0 < 1→True
[1, 2, 3] < [1, 2]→False
<=	左側のオブジェクトの値が右側のオブジェクトの値以下かどうか	0 <= 0→True
[1, 2, 3] <= [1, 2]→False
is	2つのオブジェクトが同一のオブジェクトかどうか	True is True→True
is not	2つのオブジェクトが同一のオブジェクトでないかどうか	True is not True→False
in	左側のオブジェクトが右側のオブジェクトに含まれているかどうか	1 in [1, 2, 3]→True
[1] in [1, 2, 3]→False
not in	左側のオブジェクトが右側のオブジェクトに含まれていないかどうか	1 not in [1, 2, 3]→False
[1] not in [1, 2, 3]→True
and	全ての条件が真かどうか	1 in [1, 2, 3] and 10 in [1, 2, 3]→False
'Py' in 'Python' and 'R' in 'Ruby'→True
or	条件のいずれかが真かどうか	'Py' in 'Ruby' or 'Python' in ['Python', 'Ruby']→True
0 > 1 or 1 > 10→False
not	直後の条件の真偽を反転する	not 'Py' in 'Python'→False
not 'P' in 'Ruby'→True
比較演算子とブール演算子
ビット演算子
　ビット演算子は、整数値を引数として、その2進数表現に対して処理を行う。例では各整数値のビット表現が分かりやすくなるように「0b」を前置して2進数表記としている。

演算子	説明	例
&	2つの整数値のビット単位論理積	0b1010 & 0b1000→8（0b1000)
|	2つの整数値のビット単位論理和	0b1010 | 0b0111→15（0b1111）
^	2つの整数値のビット単位排他的論理和	0b1010 ^ 0b0110→12（0b1100）
>>	左側の値を右側の値だけ右シフト	0b1010 >> 1→5（0b0101）
<<	左側の値を右側の値だけ左シフト	0b1010 << 1→20（0b10100）
ビット演算子
三項演算子
　三項演算子（条件式）は、条件に応じてその値を変える式である。構文を以下に示す。

値1 if 条件 else 値2

三項演算子（条件式）
　条件が真のときには値1が、そうでなければ値2がこの演算子（式）の値となる。また、これはelse以降に三項演算子を続けることもできる。以下に例を示す。

a = 1
x = 'foo' if a == 1 else 'bar'

y = 'insider.net' if a == 0 else 'deep insider' if x == 'foo' else 'atmarkit'
print(y)

三項演算子の使用例
　最初の三項演算子の使用箇所では、変数aの値が1なら変数xに'foo'が代入され、そうでなければ'bar'が代入される。その次は、三項演算子をネストさせて、変数aの値が0なら変数yに'insider.net'が代入され、そうでなければ変数xの値を調べて、これが'foo'なら'deep insider'が代入され、そうでなければ'atmarkit'が代入されるようにしている。ここでは、変数aの値は1で、変数xの値は'foo'になっているので、変数yには'deep insider'が代入される。

関数定義の基本
　最後に関数定義の基本をまとめて今回は終わりとしよう。

　関数はdef文で定義する。その基本構文を以下に示す。

def 関数名(パラメーターリスト):
    関数本体のコード
    return 戻り値

関数定義の基本
　パラメーターリストには、関数呼び出し時に呼び出し側から受け取る値を保存する変数をカンマ区切りで並べる。パラメーターにはデフォルト引数値を指定できる。指定する場合には「パラメーター名=デフォルト引数値」のように記述する。デフォルト引数値を持つパラメーターについては関数呼び出しに引数指定を省略でき、その場合にはデフォルト引数値が指定されたものとして扱われる。

　関数が何かを処理して、呼び出し側に値を返送するときには、return文にその値を並べる。複数の値を返送するときにはそれらをカンマ区切りで並べる。

　以下に例を示す。

from math import sqrt

def get_distance(x1, y1, x2=0, y2=0):
    distance = sqrt((x1-x2) ** 2 + (y1-y2) ** 2)
    return distance

print(get_distance(1, 1, 0, 0))
print(get_distance(2, 2))

関数定義の例
　この例ではmathモジュールからsqrt関数をインポートして、それを使って、2点間の距離を求める関数を定義している。パラメーターリストにはx1、y1、x2、y2があり、それぞれ最初の点のx座標とy座標、もう一つの点のx座標とy座標を受け取る。このとき、2つのパラメーターx2とy2にはデフォルト引数値を指定している。そのため、第3引数と第4引数は関数呼び出し時に省略できる。sqrt関数を使って距離を計算したら、最後にreturn文でその値を返送する。

　最後の2行はこの関数の呼び出し例で、最後の行では第3引数と第4引数の指定を省略している。

　今回はPythonの基本構成要素や基本となる構文をまとめた。次回は関数定義についてほんの少しだが詳しく、その構文をまとめていく予定だ
